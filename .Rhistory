library(bayesplot)
library(posterior)
library(cmdstanr)
## --- Directory Setup ---
# Use here() so this works regardless of where the script is launched
fig_path <- here("data", "figures", "revisions")
if (!dir.exists(fig_path)) dir.create(fig_path, recursive = TRUE) # Create directory for saving figures and results if it doesn't exist
## --- CmdStan Logic ---
# 1. Define the path
stan_path <- "C:/cmdstan/cmdstan-2.38.0"
# 2. Check if it exists before setting it
if (dir.exists(stan_path)) {
set_cmdstan_path(stan_path)
message("CmdStan successfully connected!")
} else {
warning("CmdStan not found at ", stan_path, ". Models will fall back to rstan.")
}
# Chunk 2: Loading in Data Zenodo
# These files are hosted on Zenodo at DOI: 10.5281/zenodo.16677435
options(timeout = 600) # Increase timeout to 10 minutes
# Define URLs to files on Zenodo
microclimate_url <- "https://zenodo.org/record/16677435/files/Bioclive_microclimate_shield_2024.csv?download=1"
design_url <- "https://zenodo.org/record/16677435/files/bioclive_design.csv?download=1"
weather_url <- "https://zenodo.org/records/18482920/files/TheBilt%20Weather%20station%20data%20KNMI.txt?download=1"
# Define local filenames
microclimate_file <- "data/Bioclive_microclimate_shield_2024.csv"
design_file <- "data/bioclive_design.csv"
weather_file <- "data/TheBilt Weather station data KNMI.txt"
# Create data directory if it doesn't exist
if (!dir.exists("data")) dir.create("data")
# Download microclimate data if needed
if (!file.exists(microclimate_file)) {
message("Downloading microclimate data...")
download.file(microclimate_url, destfile = microclimate_file, mode = "wb")
} else {
message("Microclimate data already exists locally.")
}
# Download design data if needed
if (!file.exists(design_file)) {
message("Downloading design file...")
download.file(design_url, destfile = design_file, mode = "wb")
} else {
message("Design file already exists locally.")
}
# Download weather data if needed
if (!file.exists(weather_file)) {
message("Downloading weather file...")
download.file(weather_url, destfile = weather_file, mode = "wb")
} else {
message("Weather file already exists locally.")
}
# Now load the data
microclimate_shield <- readr::read_csv(microclimate_file)
bioclive_design <- readr::read_csv(design_file)
weather_data <- readr::read_csv(weather_file)
# Chunk 3: Adding wall distance to Microclimate data
# Loading Bioclive design
bioclive_design <- bioclive_design|>
select(-...1) |>
mutate(subplot = paste0(plot, subplot)) |>
mutate(
dist_wall = case_when(
plot %in% 1:11 | plot %in% c(12, 22, 23, 33, 34, 44, 55, 66, 77, 45, 56, 67, 78:88) ~ 1,
plot %in% 13:21 | plot %in% 68:76 | plot %in% c(24, 35, 46, 57, 32, 43, 54, 65) ~ 2,
plot %in% 25:31 | plot %in% 58:64 | plot %in% c(36, 47, 53, 42) ~ 3,
plot %in% 37:41 | plot %in% 48:52 ~ 4,
TRUE ~ NA_real_ # If no condition matches, return NA
)
)
# Chunk 4: Cleaning up the probe data
# Cleaning up the probe data
# Lowercase plots and format the probe code
# Convert to data.table
setDT(microclimate_shield)
microclimate_shield[, subplot := tolower(subplot)]
microclimate_shield[, probe := substr(probe, 6, 13)]
# Rename columns using data.table's `setnames` for efficiency
data.table::setnames(microclimate_shield, old = names(microclimate_shield)[1:9],
new = c("index", "DateTime", "Timezone", "T1", "T2", "T3", "Moisture", "Shake", "ErrFlag"))
microclimate_shield[, V10 := NULL]  # Remove the unnecessary column
# Convert columns T1, T2, and T3 to numeric in one go
microclimate_shield[, c("T1", "T2", "T3") := lapply(.SD, as.numeric), .SDcols = c("T1", "T2", "T3")]
# Convert DateTime to POSIXct with timezone "UTC" (adjust if different format)
microclimate_shield[, DateTime := fastPOSIXct(DateTime, tz = "UTC")]
# Add a 2-hour timezone difference
microclimate_shield[, DateTime := DateTime + hours(2)]
# Extract Date and Time from the adjusted DateTime
microclimate_shield[, Date := as.Date(DateTime)]
microclimate_shield[, Time := format(DateTime, "%H:%M:%S")]
# Extract Month and year from the adjusted DateTime and add it as a new column
microclimate_shield[, Month := format(DateTime, "%B %Y")]
# Remove the Timezone column and any extra columns
microclimate_shield[, Timezone := NULL]
# getting the correct dates
microclimate_shield = microclimate_shield[microclimate_shield$DateTime >= "2024-08-05 00:00:00",]
# Rearrange columns
data.table::setcolorder(microclimate_shield, c("index", "DateTime", "Date", "Time", "Month", "probe", "subplot", "T1", "T2", "T3", "Moisture", "Shake", "ErrFlag"))
# Add shield presence/absence column based on `subplot`
microclimate_shield[, midshield := ifelse(
substr(subplot, nchar(subplot), nchar(subplot)) %in% c("a", "c") | subplot == "65d", "present",
ifelse(substr(subplot, nchar(subplot), nchar(subplot)) %in% c("b", "d") | subplot == "65c", "absent", NA_character_)
)]
# Chunk 5: Weather station data
## The bilt weather station data
# Loading the bilt weather station data
weather_data <- weather_data %>%
# Select only the variables you need
# TX: Max Temp, TG: Mean Temp, FHX: Max Wind, Q: Radiation, SQ: Sunshine
select(YYYYMMDD, TX, TG, FHX, Q, SQ) %>%
rename(
Date = YYYYMMDD,
max_temp = TX,             # Maximum temperature (in 0.1 °C)
mean_temp = TG,            # Mean temperature (in 0.1 °C)
max_windspeed = FHX,       # Highest hourly average windspeed (in 0.1 m/s)
radiation = Q,             # Global radiation (in J/cm2)
sunshine_min = SQ          # Sunshine duration (in 0.1 hours)
) %>%
mutate(
# 1. Convert Date string to Date object
Date = as.Date(as.character(Date), format = "%Y%m%d"),
# 2. Convert Temperatures from 0.1 °C to °C
max_temp = max_temp * 0.1,
mean_temp = mean_temp * 0.1,
# 3. Convert Max Windspeed from 0.1 m/s to m/s
max_windspeed = max_windspeed * 0.1,
# 4. Convert Sunshine from 0.1 hours to Minutes
# Formula: (Raw Value * 0.1) * 60  => Raw Value * 6
sunshine_min = sunshine_min * 6,
# 5. Radiation (Q) remains in J/cm2
radiation = radiation
)%>%
filter(Date >= as.Date("2024-08-05") & Date <= as.Date("2024-09-04"))
# Chunk 6: Calculating SWC microclimate data
# Universal TOMST calibration
microclimate_shield <- microclimate_shield  |>
dplyr::mutate(SWC = round((Moisture^2 * -1.34e-08
+ Moisture * 0.0002496218 + -0.1578888
), 4))
microclimate_shield$Time <- as.POSIXct(microclimate_shield$Time, format="%H:%M:%S")
# Filtering for Peak Day (6 hours) + Quality Control
microclimate_shield_day <- microclimate_shield[
format(Time, "%H:%M:%S") >= "11:00:00" &
format(Time, "%H:%M:%S") <= "17:00:00" &
!(subplot %in% c("63B", "58A")) &
(SWC > 0 | is.na(SWC)) &
# Temperature bounds (using 60 as per your last snippet)
(T1 <= 60 & T1 >= -20 | is.na(T1)) &
(T2 <= 60 & T2 >= -20 | is.na(T2)) &
(T3 <= 60 & T3 >= -20 | is.na(T3))
]
# Filtering for Deep Night (23:00 - 05:00)
# Filtering for Deep Night (6 hours) + Quality Control
# Filtering for Deep Night (23:00 - 05:00)
microclimate_shield_night <- microclimate_shield[
(format(Time, "%H:%M:%S") >= "23:00:00" | format(Time, "%H:%M:%S") <= "05:00:00") &
!(subplot %in% c("63B", "58A")) &
(SWC > 0 | is.na(SWC)) &
(T1 <= 60 & T1 >= -20 | is.na(T1)) &
(T2 <= 60 & T2 >= -20 | is.na(T2)) &
(T3 <= 60 & T3 >= -20 | is.na(T3))
]
# Chunk 7: Creating the mean and max dataframe
# Calculate the max per probe, the mean per probe for the total period
# Calculate the max per probe, the mean per probe for the total period, but group only by 'subplot' and 'Date'
microclimate_shield_total_day <- microclimate_shield_day %>%
group_by(subplot) %>%  # Group by subplot and Date only
dplyr::summarise(
min_SWC = min(SWC, na.rm = TRUE),
max_T1 = max(T1, na.rm = TRUE),
max_T2 = max(T2, na.rm = TRUE),
max_T3 = max(T3, na.rm = TRUE),
min_SWC_1 = quantile(SWC, 0.01, na.rm = TRUE),
max_T1_99 = quantile(T1, 0.99, na.rm = TRUE),
max_T2_99 = quantile(T2, 0.99, na.rm = TRUE),
max_T3_99 = quantile(T3, 0.99, na.rm = TRUE),
min_SWC_5 = quantile(SWC, 0.05, na.rm = TRUE),
max_T1_95 = quantile(T1, 0.95, na.rm = TRUE),
max_T2_95 = quantile(T2, 0.95, na.rm = TRUE),
max_T3_95 = quantile(T3, 0.95, na.rm = TRUE),
min_SWC_10 = quantile(SWC, 0.10, na.rm = TRUE),
max_T1_90 = quantile(T1, 0.90, na.rm = TRUE),
max_T2_90 = quantile(T2, 0.90, na.rm = TRUE),
max_T3_90 = quantile(T3, 0.90, na.rm = TRUE)
) %>%
ungroup()  # Ungroup after summarisation
# Now join the original data back to keep 'probe' and 'midshield' columns
microclimate_shield_total_day <- microclimate_shield_total_day %>%
left_join(
microclimate_shield %>%
select(subplot, probe, midshield) %>%
distinct(),  # Keep distinct rows of 'probe' and 'midshield' for each subplot & Date
by = c("subplot")
) |>
left_join(bioclive_design)
# Calculate the min per probe, the mean per probe for the total period, but group only by 'subplot' and 'Date'
microclimate_shield_total_night <- microclimate_shield_night %>%
group_by(subplot) %>%
dplyr::summarise(
# absolute mins
min_SWC = min(SWC, na.rm = TRUE),
min_T1 = min(T1, na.rm = TRUE),
min_T2 = min(T2, na.rm = TRUE),
min_T3 = min(T3, na.rm = TRUE),
# Lower quarantines (cold extremes)
min_T1_01 = quantile(T1, 0.01, na.rm = TRUE),
min_T2_01 = quantile(T2, 0.01, na.rm = TRUE),
min_T3_01 = quantile(T3, 0.01, na.rm = TRUE),
min_T1_05 = quantile(T1, 0.05, na.rm = TRUE),
min_T2_05 = quantile(T2, 0.05, na.rm = TRUE),
min_T3_05 = quantile(T3, 0.05, na.rm = TRUE),
min_T1_10 = quantile(T1, 0.10, na.rm = TRUE),
min_T2_10 = quantile(T2, 0.10, na.rm = TRUE),
min_T3_10 = quantile(T3, 0.10, na.rm = TRUE),
# SWC quantiles
min_SWC_1 = quantile(SWC, 0.01, na.rm = TRUE),
min_SWC_5 = quantile(SWC, 0.05, na.rm = TRUE),
min_SWC_10 = quantile(SWC, 0.10, na.rm = TRUE)
) %>%
ungroup()
# Now join the original data back to keep 'probe' and 'midshield' columns
microclimate_shield_total_night <- microclimate_shield_total_night %>%
left_join(
microclimate_shield %>%
select(subplot, probe, midshield) %>%
distinct(),  # Keep distinct rows of 'probe' and 'midshield' for each subplot & Date
by = c("subplot")
) |>
left_join(bioclive_design)
# Chunk 8: Creating the mean and max dataframe
# Calculate the max per probe, the mean per probe per day
# Calculate the max per probe, the mean per probe per day, but group only by 'subplot' and 'Date'
microclimate_shield_date_day <- microclimate_shield_day %>%
group_by(subplot, Date) %>%  # Group by subplot and Date only
dplyr::summarise(
min_SWC = min(SWC, na.rm = TRUE),
max_T1 = max(T1, na.rm = TRUE),
max_T2 = max(T2, na.rm = TRUE),
max_T3 = max(T3, na.rm = TRUE),
min_SWC_1 = quantile(SWC, 0.01, na.rm = TRUE),
max_T1_99 = quantile(T1, 0.99, na.rm = TRUE),
max_T2_99 = quantile(T2, 0.99, na.rm = TRUE),
max_T3_99 = quantile(T3, 0.99, na.rm = TRUE),
min_SWC_5 = quantile(SWC, 0.05, na.rm = TRUE),
max_T1_95 = quantile(T1, 0.95, na.rm = TRUE),
max_T2_95 = quantile(T2, 0.95, na.rm = TRUE),
max_T3_95 = quantile(T3, 0.95, na.rm = TRUE),
min_SWC_10 = quantile(SWC, 0.10, na.rm = TRUE),
max_T1_90 = quantile(T1, 0.90, na.rm = TRUE),
max_T2_90 = quantile(T2, 0.90, na.rm = TRUE),
max_T3_90 = quantile(T3, 0.90, na.rm = TRUE)
) %>%
ungroup()  # Ungroup after summarisation
# Now join the original data back to keep 'probe' and 'midshield' columns
microclimate_shield_date_day <- microclimate_shield_date_day %>%
left_join(
microclimate_shield %>%
select(subplot, Date, probe, midshield) %>%
distinct(),  # Keep distinct rows of 'probe' and 'midshield' for each subplot & Date
by = c("subplot", "Date")
) |>
left_join(bioclive_design)
# Calculate the max per probe, the mean per probe for the total period, but group only by 'subplot' and 'Date'
microclimate_shield_date_night <- microclimate_shield_night %>%
group_by(subplot, Date) %>%  # Group by subplot and Date only
dplyr::summarise(
# absolute mins
min_SWC = min(SWC, na.rm = TRUE),
min_T1 = min(T1, na.rm = TRUE),
min_T2 = min(T2, na.rm = TRUE),
min_T3 = min(T3, na.rm = TRUE),
# Lower quarantines (cold extremes)
min_T1_01 = quantile(T1, 0.01, na.rm = TRUE),
min_T2_01 = quantile(T2, 0.01, na.rm = TRUE),
min_T3_01 = quantile(T3, 0.01, na.rm = TRUE),
min_T1_05 = quantile(T1, 0.05, na.rm = TRUE),
min_T2_05 = quantile(T2, 0.05, na.rm = TRUE),
min_T3_05 = quantile(T3, 0.05, na.rm = TRUE),
min_T1_10 = quantile(T1, 0.10, na.rm = TRUE),
min_T2_10 = quantile(T2, 0.10, na.rm = TRUE),
min_T3_10 = quantile(T3, 0.10, na.rm = TRUE),
# SWC quantiles
min_SWC_1 = quantile(SWC, 0.01, na.rm = TRUE),
min_SWC_5 = quantile(SWC, 0.05, na.rm = TRUE),
min_SWC_10 = quantile(SWC, 0.10, na.rm = TRUE)
) %>%
ungroup()
# Now join the original data back to keep 'probe' and 'midshield' columns
microclimate_shield_date_night <- microclimate_shield_date_night %>%
left_join(
microclimate_shield %>%
select(subplot, probe, midshield) %>%
distinct(),  # Keep distinct rows of 'probe' and 'midshield' for each subplot & Date
by = c("subplot")
) |>
left_join(bioclive_design)
# merging with weather data
microclimate_shield_date_day <- microclimate_shield_date_day |>
left_join(weather_data, by="Date")
microclimate_shield_date_night <- microclimate_shield_date_night |>
left_join(weather_data, by="Date")
# Chunk 9: Preparing the data for analysis
# Ensure that Date is in Date format
microclimate_shield_date_day$Date <- as.Date(microclimate_shield_date_day$Date)
microclimate_shield_date_night$Date <- as.Date(microclimate_shield_date_night$Date)
microclimate_shield_date_day$yday <- format(microclimate_shield_date_day$Date, "%j")
microclimate_shield_date_day$yday = as.numeric(microclimate_shield_date_day$yday)
microclimate_shield_date_night$yday <- format(microclimate_shield_date_night$Date, "%j")
microclimate_shield_date_night$yday = as.numeric(microclimate_shield_date_night$yday)
microclimate_shield_date_day$midshield_binomial<-as.integer(if_else(microclimate_shield_date_day$midshield=="present", 1, 0))
microclimate_shield_date_night$midshield_binomial<-as.integer(if_else(microclimate_shield_date_night$midshield=="present", 1, 0))
microclimate_shield_total_day$midshield_binomial<-as.integer(if_else(microclimate_shield_total_day$midshield=="present", 1, 0))
microclimate_shield_total_night$midshield_binomial<-as.integer(if_else(microclimate_shield_total_night$midshield=="present", 1, 0))
# Chunk 10: Setting up the color palette and fonts
# Load the color palette and ensure it has enough colors for the unique levels in `treatment`
# Define the specific colors for each treatment
palette <- met.brewer("Lakota", n = 6, type = "discrete")
# Create the expanded palette for the gradient (12 colors for 12 species)
shield_colors <- c(
"present" = palette[5],
"absent" = palette[3])
loadfonts(device = "all")    # Loads the fonts
# Define a weakly informative prior for all fixed effects
priors <- prior(cauchy(0, 0.5), class = "b")
#For the total
m_max_T_95_shield_day = brm(max_T2_95 ~ midshield_binomial + (1|div) + (1|treatment) + (1|dist_wall), data = microclimate_shield_total_day,
prior=priors,
control = list(adapt_delta = 0.95),
# --- THE SPEED SETTINGS ---
backend = "cmdstanr",
cores = 4,              # Use your 4 physical cores
threads = threading(2), # Use 2 threads per chain (Within-chain parallelization)
chains = 4,
iter = 4000,
warmup = 1000,
refresh = 50            # Update the console every 50 iterations so you can watch progress
)
m_test = brm(
max_T2_95 ~ midshield_binomial + (1|div) + (1|treatment) + (1|dist_wall),
data = microclimate_shield_total_day,
prior = priors,
backend = "cmdstanr",
# REMOVE threads = threading(2)
cores = 4,
chains = 4,
iter = 500, # short test
refresh = 50
)
fit$fit$output(1)
options(brms.backend = "cmdstanr")
m_test = brm(
max_T2_95 ~ midshield_binomial + (1|div) + (1|treatment) + (1|dist_wall),
data = microclimate_shield_total_day,
prior = priors,
backend = "cmdstanr",
# REMOVE threads = threading(2)
cores = 4,
chains = 4,
iter = 500, # short test
refresh = 50
)
fit$fit$output()
fit <- try(
brm(
max_T2_95 ~ midshield_binomial + (1 | div) + (1 | treatment) + (1 | dist_wall),
data = microclimate_shield_total_day,
prior = priors,
backend = "cmdstanr",
cores = 4,
chains = 4,
iter = 500,
warmup = 250,
init = 0,
control = list(adapt_delta = 0.95),
refresh = 50
),
silent = TRUE
)
class(fit)
options(brms.save_cmdstan_config = TRUE)
brm(
max_T2_95 ~ 1,
data = microclimate_shield_total_day,
backend = "cmdstanr",
chains = 2,
iter = 200,
init = 0
)
# response
summary(microclimate_shield_total_day$max_T2_95)
anyNA(microclimate_shield_total_day$max_T2_95)
any(is.infinite(microclimate_shield_total_day$max_T2_95))
# predictor
table(microclimate_shield_total_day$midshield_binomial)
# grouping structure
table(microclimate_shield_total_day$div)
table(microclimate_shield_total_day$treatment)
table(microclimate_shield_total_day$dist_wall)
cmdstanr::check_cmdstan_toolchain()
cmdstanr::cmdstan_version()
brm(
max_T2_95 ~ 1,
data = microclimate_shield_total_day,
backend = "cmdstanr",
chains = 1,
cores = 1,
iter = 200
)
where.exe tbb.dll
where.exe tbb.dll
getwd()
# 1. Define the path to the 'correct' TBB inside your CmdStan folder
# Adjust the version number "2.38.0" if yours is different
correct_tbb_path <- "C:/cmdstan/cmdstan-2.38.0/stan/lib/stan_math/lib/tbb"
# 2. Prepend it to your Path (putting it at the very start)
Sys.setenv(PATH = paste(correct_tbb_path, Sys.getenv("PATH"), sep = ";"))
# 3. Verify: This should now show the C:/cmdstan path FIRST
system("where.exe tbb.dll", intern = TRUE)
# Define a weakly informative prior for all fixed effects
priors <- prior(cauchy(0, 0.5), class = "b")
#For the total
m_max_T_95_shield_day = brm(max_T2_95 ~ midshield_binomial + (1|div) + (1|treatment) + (1|dist_wall), data = microclimate_shield_total_day,
prior=priors,
control = list(adapt_delta = 0.95),
# --- THE SPEED SETTINGS ---
backend = "cmdstanr",
cores = 4,              # Use your 4 physical cores
threads = threading(2), # Use 2 threads per chain (Within-chain parallelization)
chains = 4,
iter = 4000,
warmup = 1000,
refresh = 50            # Update the console every 50 iterations so you can watch progress
)
#For the total
m_max_T_95_shield_day = brm(max_T2_95 ~ midshield_binomial + (1|div) + (1|treatment) + (1|dist_wall), data = microclimate_shield_total_day,
prior=priors,
control = list(adapt_delta = 0.95),
# --- THE SPEED SETTINGS ---
backend = "cmdstanr",
cores = 4,              # Use your 4 physical cores
threads = threading(2), # Use 2 threads per chain (Within-chain parallelization)
chains = 4,
iter = 4000,
warmup = 1000,
refresh = 50, # Update the console every 50 iterations so you can watch progress
force_recompile = TRUE
)
cmdstanr::clean_cmdstan_exe()
My apologies—I gave you the wrong function name for that package. This is what happens when you're fighting a PhD-level tech battle; even the "cleanup" tools have specific names.
cmdstanr::remove_all_utils() # Optional: clears some internal cached tools
unlink(list.files(tempdir(), pattern = "(.exe|.stan)", full.names = TRUE))
system("where.exe tbb.dll")
# 2. Run the model with a slightly different 'file' name to force a fresh build
m_max_T_95_shield_day = brm(
formula = max_T2_95 ~ midshield_binomial + (1|div) + (1|treatment) + (1|dist_wall),
data = microclimate_shield_total_day,
prior = priors,
control = list(adapt_delta = 0.95),
backend = "cmdstanr",
file = "m_max_T_95_fresh_run", # This forces a new save file/compilation
cores = 4,
threads = threading(2),
chains = 4,
iter = 4000,
warmup = 1000,
refresh = 50
)
#For the total
m_max_T_95_shield_day = brm(max_T2_95 ~ midshield_binomial + (1|div) + (1|treatment) + (1|dist_wall), data = microclimate_shield_total_day,
prior=priors,
control = list(adapt_delta = 0.95),
# --- THE SPEED SETTINGS ---
backend = "cmdstanr",
cores = 4,              # Use your 4 physical cores
threads = threading(2), # Use 2 threads per chain (Within-chain parallelization)
chains = 1,
iter = 4000,
warmup = 1000,
refresh = 50, # Update the console every 50 iterations so you can watch progress
force_recompile = TRUE
)
#For the total
m_max_T_95_shield_day = brm(max_T2_95 ~ midshield_binomial + (1|div) + (1|treatment) + (1|dist_wall), data = microclimate_shield_total_day,
prior=priors,
control = list(adapt_delta = 0.95),
# --- THE SPEED SETTINGS ---
backend = "cmdstanr",
cores = 4,              # Use your 4 physical cores
threads = threading(2), # Use 2 threads per chain (Within-chain parallelization)
chains = 1,
iter = 4000,
warmup = 1000,
refresh = 50, # Update the console every 50 iterations so you can watch progress
)
#For the total
m_max_T_95_shield_day = brm(max_T2_95 ~ midshield_binomial + (1|div) + (1|treatment) + (1|dist_wall), data = microclimate_shield_total_day,
prior=priors,
control = list(adapt_delta = 0.95),
# --- THE SPEED SETTINGS ---
backend = "cmdstanr",
cores = 4,              # Use your 4 physical cores
threads = threading(2), # Use 2 threads per chain (Within-chain parallelization)
chains = 4,
iter = 1000,
warmup = 1000,
refresh = 50, # Update the console every 50 iterations so you can watch progress
)
nCores = detectCores()
library(brms)
nCores = detectCores()
detectCores() # Check how many cores you have for parallel processing
library(parallel)
detectCores()
